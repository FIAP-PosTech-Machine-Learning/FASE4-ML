{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Treinamento do Modelo LSTM\n",
    "\n",
    "Neste notebook, iremos desenvolver e treinar um modelo LSTM para prever o valor de fechamento de ações com base em dados históricos. Vamos seguir os passos de pré-processamento, construção do modelo, treinamento e avaliação."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Importando bibliotecas necessárias\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "from sklearn.preprocessing import MinMaxScaler\n",
    "from keras.models import Sequential\n",
    "from keras.layers import LSTM, Dense, Dropout\n",
    "from keras.callbacks import EarlyStopping\n",
    "\n",
    "# Definindo o símbolo da ação e o intervalo de datas\n",
    "symbol = 'DIS'\n",
    "start_date = '2018-01-01'\n",
    "end_date = '2024-07-20'\n",
    "\n",
    "# Carregando os dados\n",
    "df = pd.read_csv('../data/dataset.csv')\n",
    "df['Date'] = pd.to_datetime(df['Date'])\n",
    "df.set_index('Date', inplace=True)\n",
    "df = df[['Close']]\n",
    "\n",
    "# Normalizando os dados\n",
    "scaler = MinMaxScaler(feature_range=(0, 1))\n",
    "scaled_data = scaler.fit_transform(df)\n",
    "\n",
    "# Criando os conjuntos de dados de treinamento e teste\n",
    "train_size = int(len(scaled_data) * 0.8)\n",
    "train_data = scaled_data[:train_size]\n",
    "test_data = scaled_data[train_size:]\n",
    "\n",
    "# Função para criar os conjuntos de dados de entrada e saída\n",
    "def create_dataset(data, time_step=1):\n",
    "    X, y = [], []\n",
    "    for i in range(len(data) - time_step - 1):\n",
    "        X.append(data[i:(i + time_step), 0])\n",
    "        y.append(data[i + time_step, 0])\n",
    "    return np.array(X), np.array(y)\n",
    "\n",
    "# Definindo o número de passos de tempo\n",
    "time_step = 60\n",
    "X_train, y_train = create_dataset(train_data, time_step)\n",
    "X_test, y_test = create_dataset(test_data, time_step)\n",
    "\n",
    "# Reshape dos dados para o formato [amostras, passos de tempo, características]\n",
    "X_train = X_train.reshape(X_train.shape[0], X_train.shape[1], 1)\n",
    "X_test = X_test.reshape(X_test.shape[0], X_test.shape[1], 1)\n",
    "\n",
    "# Construindo o modelo LSTM\n",
    "model = Sequential()\n",
    "model.add(LSTM(50, return_sequences=True, input_shape=(X_train.shape[1], 1)))\n",
    "model.add(Dropout(0.2))\n",
    "model.add(LSTM(50, return_sequences=False))\n",
    "model.add(Dropout(0.2))\n",
    "model.add(Dense(1))\n",
    "\n",
    "# Compilando o modelo\n",
    "model.compile(optimizer='adam', loss='mean_squared_error')\n",
    "\n",
    "# Treinando o modelo\n",
    "early_stopping = EarlyStopping(monitor='loss', patience=5)\n",
    "model.fit(X_train, y_train, epochs=100, batch_size=32, callbacks=[early_stopping])\n",
    "\n",
    "# Avaliando o modelo\n",
    "train_predict = model.predict(X_train)\n",
    "test_predict = model.predict(X_test)\n",
    "\n",
    "# Invertendo a normalização para calcular o erro\n",
    "train_predict = scaler.inverse_transform(train_predict)\n",
    "test_predict = scaler.inverse_transform(test_predict)\n",
    "y_train = scaler.inverse_transform(y_train.reshape(-1, 1))\n",
    "y_test = scaler.inverse_transform(y_test.reshape(-1, 1))\n",
    "\n",
    "# Calculando as métricas de avaliação\n",
    "train_rmse = np.sqrt(np.mean((train_predict - y_train) ** 2))\n",
    "test_rmse = np.sqrt(np.mean((test_predict - y_test) ** 2))\n",
    "print(f'Train RMSE: {train_rmse}')\n",
    "print(f'Test RMSE: {test_rmse}')\n",
    "\n",
    "# Salvando o modelo\n",
    "model.save('../models/lstm_model.h5')\n",
    "\n",
    "# Visualizando os resultados\n",
    "plt.figure(figsize=(14, 5))\n",
    "plt.plot(df.index[time_step:len(train_predict) + time_step], train_predict, label='Previsão de Treinamento')\n",
    "plt.plot(df.index[len(train_predict) + (time_step * 2) + 1:len(df) - 1], test_predict, label='Previsão de Teste')\n",
    "plt.plot(df['Close'], label='Valor Real')\n",
    "plt.title('Previsão de Preços de Ações com LSTM')\n",
    "plt.xlabel('Data')\n",
    "plt.ylabel('Preço de Fechamento')\n",
    "plt.legend()\n",
    "plt.show()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}